# -*- coding: utf-8 -*-

import re
from os import path, getcwd, listdir, remove, chdir
from sys import argv
import subprocess
from yaml import load
from shutil import rmtree
from slugify import slugify
from datetime import date, datetime
from unidecode import unidecode
import staticjinja
import argh
from watchdog.events import FileSystemEventHandler

from govlabstatic.cli import Manager

_TODAY = date.today()

# Define constants for the deployment.
_SASSPATH = path.join(getcwd(), 'sass')
_SEARCHPATH = path.join(getcwd(), 'templates')
_OUTPUTPATH = path.join(getcwd(), 'site')
_DATAPATH = path.join(getcwd(), 'data')

# Load the data we want to use in the templates.
_TEAM = path.join(_DATAPATH, 'team.yaml')
_FUNDERS = path.join(_DATAPATH, 'funders.yaml')

_SLUG = lambda x: slugify(unicode(unidecode(unicode(x).lower())) if x else u'')


def filters():
    return {'slug': _SLUG}


def clean():
    '''
    Clean the output folder.
    '''

    if path.exists(_OUTPUTPATH):
        rmtree(_OUTPUTPATH)


def render_detail_pages(env, template, **kwargs):
    '''
    generic staticjinja rule for generating detail pages.
    use:    adding a file
            /templates/(name).custom will use
            /templates/_(name).html as a template to generate pages based on
            /data/(name).yaml
    generated file names are based on a 'title' element in the yaml entry
    a context for the template is generated by a yaml 'context' element in the (name).custom file, or defaults to 'this'
    '''

    print('Found custom generator: ' + template.name)
    page_name = re.sub(r'.custom$', '', template.name, 1)
    page_template = env.get_template('_' + page_name + '.html')
    yaml_source = load(open(path.join(_DATAPATH, page_name + '.yaml')))
    custom_yaml = load(open(path.join(_SEARCHPATH, template.name)))
    if custom_yaml['context']:
        _context = custom_yaml['context']
    else:
        _context = 'this'
    for index, yaml in enumerate(yaml_source):
        out = '%s.html' % (_SLUG(yaml['title']),)
        page_template.stream({_context : yaml}, **kwargs).\
            dump(path.join(env.outpath, out))


class ReloadingContext(FileSystemEventHandler):
    '''
    Regenerates a template context, and the static site, whenever files
    in the data directory change.
    '''

    path = _DATAPATH

    def __init__(self):
        FileSystemEventHandler.__init__(self)
        self.cache_context()

    def get(self):
        return self._cached_context

    def add_to(self, manager):
        self.site = manager.site
        manager.watcher.observer.schedule(self, self.path)

    def on_any_event(self, event):
        self.cache_context()
        self.site.render_templates(self.site.templates)

    def cache_context(self):
        self._cached_context = self.build_context()

    def build_context(self):
        dic = {}

        dic['team'] = load(open(_TEAM))
        dic['funders'] = load(open(_FUNDERS))

        return dic

def deploy():
    '''
    Deploy the site to production.
    '''

    subprocess.check_call(
        'git subtree push --prefix site origin gh-pages',
        shell=True
    )

if __name__ == '__main__':
    context = ReloadingContext()

    site = staticjinja.make_site(
        filters=filters(),
        outpath=_OUTPUTPATH,
        contexts=[
            (r'.*.html', context.get),
            (r'.*.custom', context.get),
        ],
        rules=[
            (r'.*.custom', render_detail_pages)
        ],
        searchpath=_SEARCHPATH,
        staticpaths=['static']
    )

    manager = Manager(
        sass_src_path=path.join(_SASSPATH, 'styles.scss'),
        sass_dest_path=path.join(_SEARCHPATH, 'static', 'styles',
                                 'styles.css'),
        site=site,
        site_name='odi-draft',
    )
    context.add_to(manager)
    argh.add_commands(manager.parser, [deploy, clean])

    manager.run()
